/**
 * Go SDK for OpenFGA
 *
 * API version: 1.x
 * Website: https://openfga.dev
 * Documentation: https://openfga.dev/docs
 * Support: https://openfga.dev/community
 * License: [Apache-2.0](https://github.com/openfga/go-sdk/blob/main/LICENSE)
 *
 * NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
 */

package openfga

import (
	"bufio"
	"context"
	"encoding/json"
	"errors"
	"io"
	"net/http"
	"net/url"
	"strings"
)

type StreamedListObjectsChannel struct {
	Objects chan StreamedListObjectsResponse
	Errors  chan error
	cancel  context.CancelFunc
}

func (s *StreamedListObjectsChannel) Close() {
	if s.cancel != nil {
		s.cancel()
	}
}

func ProcessStreamedListObjectsResponse(ctx context.Context, httpResponse *http.Response, bufferSize int) (*StreamedListObjectsChannel, error) {
	streamCtx, cancel := context.WithCancel(ctx)

	// Use default buffer size of 10 if not specified or invalid
	if bufferSize <= 0 {
		bufferSize = 10
	}

	channel := &StreamedListObjectsChannel{
		Objects: make(chan StreamedListObjectsResponse, bufferSize),
		Errors:  make(chan error, 1),
		cancel:  cancel,
	}

	if httpResponse == nil || httpResponse.Body == nil {
		cancel()
		return nil, errors.New("response or response body is nil")
	}

	go func() {
		defer close(channel.Objects)
		defer close(channel.Errors)
		defer cancel()
		defer func(Body io.ReadCloser) {
			err := Body.Close()
			if err != nil {
				channel.Errors <- err
			}
		}(httpResponse.Body)

		scanner := bufio.NewScanner(httpResponse.Body)
		// Allow large NDJSON entries (up to 10MB). Tune as needed.
		buf := make([]byte, 0, 64*1024)
		scanner.Buffer(buf, 10*1024*1024)
		for scanner.Scan() {
			select {
			case <-streamCtx.Done():
				channel.Errors <- streamCtx.Err()
				return
			default:
				line := scanner.Bytes()
				if len(line) == 0 {
					continue
				}

				var streamResult StreamResultOfStreamedListObjectsResponse
				if err := json.Unmarshal(line, &streamResult); err != nil {
					channel.Errors <- err
					return
				}

				if streamResult.Error != nil {
					msg := "stream error"
					if streamResult.Error.Message != nil {
						msg = *streamResult.Error.Message
					}
					channel.Errors <- errors.New(msg)
					return
				}

				if streamResult.Result != nil {
					select {
					case <-streamCtx.Done():
						channel.Errors <- streamCtx.Err()
						return
					case channel.Objects <- *streamResult.Result:
					}
				}
			}
		}

		if err := scanner.Err(); err != nil {
			// Prefer context error if we were canceled to avoid surfacing net/http "use of closed network connection".
			if streamCtx.Err() != nil {
				channel.Errors <- streamCtx.Err()
				return
			}
			channel.Errors <- err
		}
	}()

	return channel, nil
}

func ExecuteStreamedListObjects(client *APIClient, ctx context.Context, storeId string, body ListObjectsRequest, options RequestOptions) (*StreamedListObjectsChannel, error) {
	return ExecuteStreamedListObjectsWithBufferSize(client, ctx, storeId, body, options, 0)
}

func ExecuteStreamedListObjectsWithBufferSize(client *APIClient, ctx context.Context, storeId string, body ListObjectsRequest, options RequestOptions, bufferSize int) (*StreamedListObjectsChannel, error) {
	path := "/stores/{store_id}/streamed-list-objects"
	if storeId == "" {
		return nil, reportError("storeId is required and must be specified")
	}

	path = strings.ReplaceAll(path, "{"+"store_id"+"}", url.PathEscape(parameterToString(storeId, "")))

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}

	localVarHTTPContentType := "application/json"
	localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	localVarHeaderParams["Accept"] = "application/x-ndjson"

	for header, val := range options.Headers {
		localVarHeaderParams[header] = val
	}

	req, err := client.prepareRequest(ctx, path, http.MethodPost, body, localVarHeaderParams, localVarQueryParams)
	if err != nil {
		return nil, err
	}

	httpResponse, err := client.callAPI(req)
	if err != nil || httpResponse == nil {
		return nil, err
	}

	if httpResponse.StatusCode >= http.StatusMultipleChoices {
		responseBody, readErr := io.ReadAll(httpResponse.Body)
		_ = httpResponse.Body.Close()
		if readErr != nil {
			return nil, readErr
		}
		err = client.handleAPIError(httpResponse, responseBody, body, "StreamedListObjects", storeId)
		return nil, err
	}

	return ProcessStreamedListObjectsResponse(ctx, httpResponse, bufferSize)
}
